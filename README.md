뉴렉처 스프링 aop 2강 3강 내용입니다. 주제는 어노테이션 11강에서도 말했지만 혹시 히스토리를 통해 제 과거 스프링 공부를 보신다면
README.AD는 RAW로 봐주시기 바랍니다. 과거에는 지금처럼 태그를 보이게 해놓지않아서 안보일겁니다.
읽기전에! 제가 이해하기위해 작성한 글이므로 반말 존댓말이 섞일수 있으며 맞춤법이 잘 맞지 않을수 있으므로 양해 부탁드립니다. 그럼 설명ㄱ!
그리고 좀 지저분해서 그전 주석내용들 몇개는 지웠어요 보실거라면 히스토리 보시면됩니다!!!

---------------------------------------------------------------------------------------------------------

일단 앞에 교육에서 저희는 aop에 대해서 배우게됬는데요. 이번에는 스프링이아닌 순수자바로 aop를 구현해보는 학습을 하였습니다. 이번 실습을
위해서 spring.entity 패키지를 복사해서 aop.entity를 만들었고 spring.aop 패키지를 만들어 Program 클래스를 새로 만들었습니다.
그럼 설명하겠습니다. 만약 저희가 성적을 구하는 프로그램에서 이프로그램의 성적을 구하는 시간이 얼마나 걸리는지 확인하려면 어떻게 헤야 될까요?
우선 여기서 성적을 구하는데 걸리는 시간을 구하는 것은 사용자의 관점일까요? 당연히 아닙니다. 이것은 저희같은 개발자의 관점이죠. 만약 이런것을 구현하는데 aop가 없다면 어떻게 될까요? 직접 그 소스코드에 필요한코드를 구현해서 실행해야겠죠. 이렇게 해도 당연히 되겠지만 문제가 
하나 있습니다. 저희는 무조건 확인을위해서 이 소스코드에 구현을 해야하고 만약 비슷한 함수를 확인해야되는게 여러개라면 그 여러개의 코드에 모두
소스코드를 수정해야합니다. 하지만 저희는 aop를 통해서 cross-cutting-concern 개발자의 관점의 코드를 꼇다 뺐다 하는것처럼 구현할수 있습니다.
방법은 이렇습니다. 프로그램 코드에 프록시를 추가하여 사용하는 사용자의 로직을 가져와 앞뒤로 개발자의 로직을 수행하고 결과를 확인하는것이죠 여기서 중요한점은 SongExam과같은 소스코드를 안건드리고 실행하는 Program 만을 건든다는 겁니다. 소스코드를 똑같이 건드는것이니까 이것의
의미를 잘 모를지도 모릅니다. 일단 여기까지만 알고 Program 코드 설명하겠습니다.
Program코드를 보시면 Exam타입의 인터페이스로 exam변수를 SongExam으로 초기화주었고 proxy라는 변수를 초기화 하였습니다. proxy 변수에 위에서 설명한 프록시의 기능을 추가하기 위해서 만든 변수인데요. 
이 변수에 <code>(Exam) Proxy.newProxyInstance</code>다음과 같이 프록시의 인스턴스를 Exam으로 캐스팅해서 생성해주었습니다.
<code>newProxyInstance()</code>의 매개변수는 첫번째 loader인데요 loader는 런타임에 자바 클래스를 동적으로 로드 즉 연결하는
역할을 합니다. 그렇게 사용할 객체의 클래스의 로더를 매개변수로 지정해주고 다음 매개변수로 이 클래스가 상속한 인터페이스를 넣어준다.
이때 인터페이스가 여러개 있을수 있으므로 코드에서처럼 배열로 클래스의 정보를 넣어주었다. 세번째는 <code>InvocationHandler()</code>
를 넣어주었는데 <code>InvocationHandler</code>객체를 넣어주면 되지만 나는 익명으로 구현하여 넣어주었다. 필수적으로 구현해야되는 
invoke함수가있는데 여기에다가 개발자의 로직을 추가하여 실행할수있다. invoke함수 안에 내가 작성한 코드들은 대부분 이해가 갈텐데 
<code>Object result = method.invoke(exam, args);</code> 이부분은 잘 몰를것이다. method같은 경우는 invoke 함수의 매개변수인데 실제업무의 메소드이다. 그리고 metohd의 invoke함수가 있는데 여기에 인자로 실제업무를 실행할 변수 exam과 위에 invoke 매개변수중 실제업무의 파라미터를 가져오는 args를 인자로 넣어 필요한 파라미터를 빠짐없이 넣도록해 실제업무의 메소드를 구현할수있다.
이제 아래에 결과에 보면 <code>total(),avg()</code>이렇게 둘다 구현한것을 볼수있는데 만약 aop를 구현한다면 필요한 실제업무를 가져와
개발자의 로직을 손쉽게 낄수있고, 또 실제 소스코드를 수정할 필요가 없어 확인할 코드를 구현하고 쓰지않을때 주석처리하는 번거로움을 없엘수있다.
aop를 구현했을경우 저기서 개발자의 로직을 그만쓰고싶으면 출력하는 형태를 변수 exam으로 쓰면 되고 개발자의 로직을 추가하고싶으면 proxy 변수를 써서 확인할수있다.